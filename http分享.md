__HTTP__
==
## __历史:__
__60 年代__，美国国防部高等研究计划署（ARPA）建立了 ARPA 网，它有四个分布在各地的节点，被认为是如今互联网的“始祖”  
(美苏冷战的产物，存在不同电脑的网络兼容性问题，战争时期追求数据交互的可靠性)。

__70 年代__，基于对 ARPA 网的实践和思考，研究人员发明出了著名的 TCP/IP 协议。由于具有良好的分层结构和稳定的性能，TCP/IP 协议迅速战胜其他竞争对手流行起来，并在 80 年代中期进入了 UNIX 系统内核，促使更多的计算机接入了互联网。  
（传真机，电子邮件，ftp, 表格编辑软件）

__1980年__，一个偶然的机会，伯纳斯·李来到位于瑞士日内瓦的欧洲核子研究中心（CERN）干起了软件工程师的工作。工作过程中，他要频繁地与世界各地的科学家们沟通联系，和他们交换、分析数不清的报告和数据，经常不得不重复回答一些问题，繁琐的过程实在令人烦恼。他希望能够有一种工具，让大家能够不管身处何地，都能够通过计算机网络去简单快捷地访问其他人的数据。

__1989年__，任职于欧洲核子研究中心（CERN）的蒂姆·伯纳斯 - 李（Tim Berners-Lee）发表了一篇论文

- URI：即统一资源标识符，作为互联网上资源的唯一身份；  
- HTML：即超文本标记语言，描述超文本文档；  
- HTTP：即超文本传输协议，用来传输超文本。

这一年http诞生了。http0.9
只支持get，响应请求后立即就关闭了连接，功能非常有限。但它作为一个“原型”，充分验证了 Web 服务的可行性  

__1996__ 年 HTTP/1.0 版本在 正式发布。它在多方面增强了 0.9 版，形式上已经和我们现在的 HTTP 差别不大了，
- 增加了 HEAD、POST 等新方法；
- 增加了响应状态码，标记可能的错误原因；
- 引入了协议版本号概念；
- 引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；
- 传输的数据不再仅限于文本。

__1999 年__，HTTP/1.1 发布了 RFC 文档，从版本号我们就可以看到，HTTP/1.1 是对 HTTP/1.0 的小幅度修正。但一个重要的区别是：它是一个“正式的标准”，而不是一份可有可无的“参考文档”。这意味着今后互联网上所有的浏览器、服务器、网关、代理等等，只要用到 HTTP 协议，就必须严格遵守这个标准，相当于是互联网世界的一个“立法”。  
HTTP/1.1 主要的变更点有：  
- 增加了 PUT、DELETE 等新的方法；  
- 增加了缓存管理和控制；  
- 明确了连接管理，允许持久连接；  
- 允许响应数据分块（chunked），利于传输大文件；  

对 HTTP 不满的意见，主要就是连接慢，无法跟上迅猛发展的互联网，但 HTTP/1.1 标准一直“岿然不动” 无奈之下人们只好发明各式各样的“小花招”来缓解这些问题，比如以前常见的切图、JS 合并等网页优化手段,
 Google 首先开发了自己的浏览器 Chrome，然后推出了新的 SPDY 协议，并在 Chrome 里应用于自家的服务器
最终在 2015 年发布了 HTTP/2，RFC 编号 7540。  
HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力  
主要的特点有：  
- 二进制协议，不再是纯文本；  
- 使用专用算法压缩头部，减少数据传输量；  
- 允许服务器主动向客户端推送数据；
- 增强了安全性，“事实上”要求加密通信。  

在 HTTP/2 还处于草案之时，Google 又发明了一个新的协议，叫做 QUIC，而且还是相同的“套路”，继续在 Chrome 和自家服务器里试验着“玩”，依托它的庞大用户量和数据量，持续地推动 QUIC 协议成为互联网上的“既成事实”。“功夫不负有心人”，当然也是因为 QUIC 确实自身素质过硬。在去年，也就是 2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段，也许两三年后就会正式发布，到时候我们很可能会跳过 HTTP/2 直接进入 HTTP/3。

-----------------
## __URI：__
URI，也就是统一资源标识符，URI 不完全等同于网址，它包含有 URL 和 URN 两个部分，在 HTTP 世界里用的网址实际上是 URL——统一资源定位符（Uniform Resource Locator）。但因为 URL 实在是太普及了，所以常常把这两者简单地视为相等

### __URI 的格式__
URI不仅能够标记万维网的资源，也可以标记其他的，如邮件系统、本地文件系统等任意资源。而“资源”既可以是存在磁盘上的静态文本、页面数据，也可以是由 Java、PHP 提供的动态服务
<img src="https://static001.geekbang.org/resource/image/ff/38/ff41d020c7a27d1e8191057f0e658b38.png">
scheme，翻译成中文叫“方案名”或者“协议名”，表示资源应该使用哪种协议来访问。  
User:passwd@ : 身份信息，但是不推荐这样使用, 但现在已经不推荐使用这种形式了（RFC7230），因为它把敏感信息以明文形式暴露出来，存在严重的安全隐患
://之后表示资源所在的主机名加端口，如果不写http默认端口是80，https默认端口是443  
path 采用了类似文件系统“目录”“路径”的表示方式，因为早期互联网上的计算机多是 UNIX 系统，所以采用了 UNIX 的“/”风格  
```
http://nginx.org
http://www.chrono.com:8080/11-1
https://tools.ietf.org/html/rfc7230
file:///D:/http_study/www/
```
query: 查询参数，以“?”开始，但不包含“?”。key=value字符串，用&连接  
```
https://search.jd.com/Search?keyword=openresty&enc=utf-8&qrst=1&rt=1&stop=1&vt=2&wq=openresty&psort=3&click=0
```
片段标识符“#fragment”，它是 URI 所定位的资源内部的一个“锚点”或者说是“标签”，浏览器可以在获取资源后直接跳转到它指示的位置, 但片段标识符仅能由浏览器这样的客户端使用，服务器是看不到的。也就是说，浏览器永远不会把带“#fragment”的 URI 发送给服务器，服务器也永远不会用这种方式去处理资源的片段。

### path、query 里出现特殊字符怎么办？  
URI的编码, 直接把非ASCII 码或特殊字符转换成十六进制字节值，然后前面加一个“%”，中文、日文等通常使用UTF-8编码后再转义。  
空格被转义成“%20”  
银河”会被转义成“%E9%93%B6%E6%B2%B3  
```
百度搜索香蕉，在浏览器复制链接出来到其他编辑器的样子。
https://www.baidu.com/s?wd=香蕉
https://www.baidu.com/s?wd=%E9%A6%99%E8%95%89
```
------------------------------
## __DNS:__
1）
域名是一个有层次的结构，是一串用“.”分隔的多个单词，最右边的被称为“顶级域名”，然后是“二级域名”，层级关系向左依次降低。最左边的是主机名，
```
www.time.geekbang.org
www.baidu.com
```
这里的“org”就是顶级域名，“geekbang”是二级域名，“time”则是主机名, www代表万维网服务。

2）
DNS 的核心系统是一个树状、分布式服务，基本对应域名的结构：根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址。
<img src="https://static001.geekbang.org/resource/image/6b/f2/6b020454987543efdd1cf6ddec784bf2.png">

在这里根域名服务器是关键，它必须是众所周知的，否则下面的各级服务器就无从谈起了。目前全世界共有 13 组根域名服务器，又有数百台的镜像，保证一定能够被访问到。

例如，你要访问“www.apple.com”，就要进行下面的三次查询：访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；最后访问“apple.com”域名服务器，就得到了“www.apple.com”的地址。

3）但如果全世界的网民都往这个系统里挤，即使不挤瘫痪了，访问速度也会很慢。所以在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，并且能够更快地获取结果，基本思路就是“缓存”。
有“野生”DNS 服务器、操作系统缓存和 hosts 文件操作系统

<img src="https://static001.geekbang.org/resource/image/e5/ac/e51df3245609880641043af65bba94ac.png">  

浏览器缓存->操作系统dnscache ->hosts文件->非权威域名服务器->根域名服务器->顶级域名服务器->二级域名服务器->权威域名服务器。

4）查询方式  
- 递归查询  
递归查询是一种DNS 服务器的查询模式，在该模式下DNS 服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机。如果DNS 服务器本地没有存储查询DNS 信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机。  
- 迭代查询  
DNS 服务器另外一种查询方式为迭代查询，DNS 服务器会向客户机提供其他能够解析查询请求的DNS 服务器地址，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台DNS 服务器地址，客户机再向这台DNS 服务器提交请求，依次循环直到返回查询的结果
为止。  
<img src="https://img2.baidu.com/it/u=234386743,1080002279&fm=253&fmt=auto&app=138&f=JPEG?w=630&h=484">  
  
----------------------------
## __HTTP报文：__
1）HTTP 协议的请求报文和响应报文的结构基本相同  
由三大部分组成：  
起始行（start line）：描述请求或响应的基本信息；  
头部字段集合（header）：使用 key-value 形式更详细地说明报文；  
消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。  

HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”  
<img src="https://static001.geekbang.org/resource/image/62/3c/62e061618977565c22c2cf09930e1d3c.png" width="50%">  
<img src="https://static001.geekbang.org/resource/image/b1/df/b191c8760c8ad33acd9bb005b251a2df.png" width="80%">  

### 请求行  
简要地描述了客户端想要如何操作服务器端的资源。
请求行由三部分构成：  
请求方法：是一个动词，如 GET/POST，表示对资源的操作；  
请求目标：通常是一个 URI，标记了请求方法要操作的资源；  
版本号：表示报文使用的 HTTP 协议版本。  

<img src="https://static001.geekbang.org/resource/image/36/b9/36108959084392065f36dff3e12967b9.png">

### 状态行  
是服务器响应的状态。  
同样也是由三部分构成：  
版本号：表示报文使用的 HTTP 协议版本；  
状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；  
原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。  

<img src="https://static001.geekbang.org/resource/image/a1/00/a1477b903cd4d5a69686683c0dbc3300.png">

2）使用头字段需要注意下面几点：
- 字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；
- 字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；
- 字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格,也可以没有空格；
- 字段的顺序是没有意义的，可以任意排列不影响语义；
- 字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie

3）HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为五大类：  
通用字段：在请求头和响应头里都可以出现；cache-control  
请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；cookie  
响应字段：仅能出现在响应头里，补充说明响应报文的信息；set-cookie  
实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。content-length  
扩展首部: 规范中没有定义的新首部


----------------------------
## __请求方法：__
HTTP 协议里为什么要有“请求方法”这个东西呢？

这就要从 HTTP 协议设计时的定位说起了。还记得吗？蒂姆·伯纳斯 - 李最初设想的是要用 HTTP 协议构建一个超链接文档系统，使用 URI 来定位这些文档，也就是资源。那么，该怎么在协议里操作这些资源呢？很显然，需要有某种“动作的指示”，告诉操作这些资源的方式。所以，就这么出现了“请求方法”。它的实际含义就是客户端发出了一个“动作指令”，要求服务器端对 URI 定位的资源执行这个动作。

目前 HTTP/1.1 规定了八种方法，单词都必须是大写的形式

- GET：获取资源，可以理解为读取或者下载数据；

- HEAD：获取资源的元信息；所谓的元信息就是响应头, 因为它的响应头与 GET 完全相同，所以可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费

- POST：向资源提交数据，相当于写入或上传数据；

- PUT：作用与 POST 类似，也可以向服务器提交数据，但与 POST 存在微妙的不同，通常 POST 表示的是“新建” “create”的含义，而 PUT 则是“修改”“update”的含义。在实际应用中，PUT 用到的比较少。而且，因为它与 POST 的语义、功能太过近似，有的服务器甚至就直接禁止使用 PUT 方法，只用 POST 方法上传数据

- DELETE：因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记。当然，更多的时候服务器就直接不处理 DELETE 请求

- CONNECT：建立特殊的连接隧道； 要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色

- OPTIONS：列出可对资源实行的方法；方法要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回。它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持

- TRACE：追踪请求 - 响应的传输路径。 方法多用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用

### 安全与幂等概念
1. 安全是指请求方法不会破坏服务器上的资源，HTTP RFC定义了以下安全方法：GET，HEAD，OPTIONS和TRACE
2. 幂等是指多次“幂”后结果相等，GET 和 HEAD 既是安全的也是幂等的，DELETE 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。POST 和 PUT 的幂等性质就略费解一点。按照 RFC 里的语义，POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的；而 PUT 是“替换或更新数据”，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。OPTIONS，TRACE

----------------------------
## __状态码：__
这五类的具体含义是：
- 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；  
“101 Switching Protocols”。它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket
- 2××：成功，报文已经收到并被正确处理；  
> 常用的有 :
> - 200：OK
> - 204: “204 No Content” 含义和200相同，但是响应头后没有 body 数据。
> - 206：和200一样是成功处理了数据，不过body是数据的一部分
- 3××：重定向，资源位置发生变动，需要客户端重新发送请求；
> - 301永久重定向，比如，你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是“永久”的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS。浏览器看到 301，就知道原来的 URI“过时”了，就会做适当的优化。比如历史记录、更新书签，下次可能就会直接用新的 URI 访问，省去了再次跳转的成本。搜索引擎的爬虫看到 301，也会更新索引库，不再使用老的 URI。  
> - 302临时重定向，比如，今天夜里网站后台要系统维护，服务暂时不可用，这就属于“临时”的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，不会做缓存优化，第二天还会访问原来的地址。浏览器或者爬虫看到 302，会认为原来的 URI 仍然有效，但暂时不可用，所以只会执行简单的跳转页面，不记录新的 URI，也不会有其他的多余动作，下次访问还是用原 URI
- 4××：客户端错误，请求报文有误，服务器无法处理；
> - 400 Bad Request 通用的错误码
> - 403 Forbidden 禁止访问资源
> - 404 Not Found
- 5××：服务器错误，服务器在处理请求时内部发生了错误。
> - 500 Internal Server Error 服务器通用错误码
> - 501 Not Implemented "即将开业，敬请期待"
> - 502 Bad Gateway 通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的
> - 503 Service Unavailable 表示服务器当前很忙，暂时无法响应服务

----------------------------
## __http特点：__
HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；

HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达；

HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；

HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；

HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。
但有时也需要用 Cookie 技术来实现“有状态”；  

在http/1.1里改为了总是默认开启keepalive长连接机制，所以现在的http已经不再是“无连接”的了